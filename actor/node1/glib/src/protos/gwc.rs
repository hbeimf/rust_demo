// This file is generated by rust-protobuf 2.8.1. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `gwc.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_8_1;

#[derive(PartialEq,Clone,Default)]
pub struct BroadcastByUID {
    // message fields
    pub uids: ::protobuf::RepeatedField<Uids>,
    pub payload: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BroadcastByUID {
    fn default() -> &'a BroadcastByUID {
        <BroadcastByUID as ::protobuf::Message>::default_instance()
    }
}

impl BroadcastByUID {
    pub fn new() -> BroadcastByUID {
        ::std::default::Default::default()
    }

    // repeated .GWC.Uids uids = 1;


    pub fn get_uids(&self) -> &[Uids] {
        &self.uids
    }
    pub fn clear_uids(&mut self) {
        self.uids.clear();
    }

    // Param is passed by value, moved
    pub fn set_uids(&mut self, v: ::protobuf::RepeatedField<Uids>) {
        self.uids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_uids(&mut self) -> &mut ::protobuf::RepeatedField<Uids> {
        &mut self.uids
    }

    // Take field
    pub fn take_uids(&mut self) -> ::protobuf::RepeatedField<Uids> {
        ::std::mem::replace(&mut self.uids, ::protobuf::RepeatedField::new())
    }

    // bytes payload = 2;


    pub fn get_payload(&self) -> &[u8] {
        &self.payload
    }
    pub fn clear_payload(&mut self) {
        self.payload.clear();
    }

    // Param is passed by value, moved
    pub fn set_payload(&mut self, v: ::std::vec::Vec<u8>) {
        self.payload = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payload(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.payload
    }

    // Take field
    pub fn take_payload(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.payload, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for BroadcastByUID {
    fn is_initialized(&self) -> bool {
        for v in &self.uids {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.uids)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.payload)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.uids {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.payload.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.payload);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.uids {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.payload.is_empty() {
            os.write_bytes(2, &self.payload)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BroadcastByUID {
        BroadcastByUID::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Uids>>(
                    "uids",
                    |m: &BroadcastByUID| { &m.uids },
                    |m: &mut BroadcastByUID| { &mut m.uids },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "payload",
                    |m: &BroadcastByUID| { &m.payload },
                    |m: &mut BroadcastByUID| { &mut m.payload },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<BroadcastByUID>(
                    "BroadcastByUID",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static BroadcastByUID {
        static mut instance: ::protobuf::lazy::Lazy<BroadcastByUID> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const BroadcastByUID,
        };
        unsafe {
            instance.get(BroadcastByUID::new)
        }
    }
}

impl ::protobuf::Clear for BroadcastByUID {
    fn clear(&mut self) {
        self.uids.clear();
        self.payload.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BroadcastByUID {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BroadcastByUID {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Uids {
    // message fields
    pub uid: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Uids {
    fn default() -> &'a Uids {
        <Uids as ::protobuf::Message>::default_instance()
    }
}

impl Uids {
    pub fn new() -> Uids {
        ::std::default::Default::default()
    }

    // string uid = 1;


    pub fn get_uid(&self) -> &str {
        &self.uid
    }
    pub fn clear_uid(&mut self) {
        self.uid.clear();
    }

    // Param is passed by value, moved
    pub fn set_uid(&mut self, v: ::std::string::String) {
        self.uid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uid(&mut self) -> &mut ::std::string::String {
        &mut self.uid
    }

    // Take field
    pub fn take_uid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.uid, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Uids {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.uid)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.uid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.uid);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.uid.is_empty() {
            os.write_string(1, &self.uid)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Uids {
        Uids::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "uid",
                    |m: &Uids| { &m.uid },
                    |m: &mut Uids| { &mut m.uid },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Uids>(
                    "Uids",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Uids {
        static mut instance: ::protobuf::lazy::Lazy<Uids> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Uids,
        };
        unsafe {
            instance.get(Uids::new)
        }
    }
}

impl ::protobuf::Clear for Uids {
    fn clear(&mut self) {
        self.uid.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Uids {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Uids {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Broadcast {
    // message fields
    pub serverType: ::std::string::String,
    pub serverID: ::std::string::String,
    pub payload: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Broadcast {
    fn default() -> &'a Broadcast {
        <Broadcast as ::protobuf::Message>::default_instance()
    }
}

impl Broadcast {
    pub fn new() -> Broadcast {
        ::std::default::Default::default()
    }

    // string serverType = 1;


    pub fn get_serverType(&self) -> &str {
        &self.serverType
    }
    pub fn clear_serverType(&mut self) {
        self.serverType.clear();
    }

    // Param is passed by value, moved
    pub fn set_serverType(&mut self, v: ::std::string::String) {
        self.serverType = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_serverType(&mut self) -> &mut ::std::string::String {
        &mut self.serverType
    }

    // Take field
    pub fn take_serverType(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.serverType, ::std::string::String::new())
    }

    // string serverID = 2;


    pub fn get_serverID(&self) -> &str {
        &self.serverID
    }
    pub fn clear_serverID(&mut self) {
        self.serverID.clear();
    }

    // Param is passed by value, moved
    pub fn set_serverID(&mut self, v: ::std::string::String) {
        self.serverID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_serverID(&mut self) -> &mut ::std::string::String {
        &mut self.serverID
    }

    // Take field
    pub fn take_serverID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.serverID, ::std::string::String::new())
    }

    // bytes payload = 3;


    pub fn get_payload(&self) -> &[u8] {
        &self.payload
    }
    pub fn clear_payload(&mut self) {
        self.payload.clear();
    }

    // Param is passed by value, moved
    pub fn set_payload(&mut self, v: ::std::vec::Vec<u8>) {
        self.payload = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payload(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.payload
    }

    // Take field
    pub fn take_payload(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.payload, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for Broadcast {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.serverType)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.serverID)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.payload)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.serverType.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.serverType);
        }
        if !self.serverID.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.serverID);
        }
        if !self.payload.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.payload);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.serverType.is_empty() {
            os.write_string(1, &self.serverType)?;
        }
        if !self.serverID.is_empty() {
            os.write_string(2, &self.serverID)?;
        }
        if !self.payload.is_empty() {
            os.write_bytes(3, &self.payload)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Broadcast {
        Broadcast::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "serverType",
                    |m: &Broadcast| { &m.serverType },
                    |m: &mut Broadcast| { &mut m.serverType },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "serverID",
                    |m: &Broadcast| { &m.serverID },
                    |m: &mut Broadcast| { &mut m.serverID },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "payload",
                    |m: &Broadcast| { &m.payload },
                    |m: &mut Broadcast| { &mut m.payload },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Broadcast>(
                    "Broadcast",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Broadcast {
        static mut instance: ::protobuf::lazy::Lazy<Broadcast> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Broadcast,
        };
        unsafe {
            instance.get(Broadcast::new)
        }
    }
}

impl ::protobuf::Clear for Broadcast {
    fn clear(&mut self) {
        self.serverType.clear();
        self.serverID.clear();
        self.payload.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Broadcast {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Broadcast {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HeartbeatReq {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HeartbeatReq {
    fn default() -> &'a HeartbeatReq {
        <HeartbeatReq as ::protobuf::Message>::default_instance()
    }
}

impl HeartbeatReq {
    pub fn new() -> HeartbeatReq {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for HeartbeatReq {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HeartbeatReq {
        HeartbeatReq::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<HeartbeatReq>(
                    "HeartbeatReq",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static HeartbeatReq {
        static mut instance: ::protobuf::lazy::Lazy<HeartbeatReq> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const HeartbeatReq,
        };
        unsafe {
            instance.get(HeartbeatReq::new)
        }
    }
}

impl ::protobuf::Clear for HeartbeatReq {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HeartbeatReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HeartbeatReq {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HeartbeatRes {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HeartbeatRes {
    fn default() -> &'a HeartbeatRes {
        <HeartbeatRes as ::protobuf::Message>::default_instance()
    }
}

impl HeartbeatRes {
    pub fn new() -> HeartbeatRes {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for HeartbeatRes {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HeartbeatRes {
        HeartbeatRes::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<HeartbeatRes>(
                    "HeartbeatRes",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static HeartbeatRes {
        static mut instance: ::protobuf::lazy::Lazy<HeartbeatRes> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const HeartbeatRes,
        };
        unsafe {
            instance.get(HeartbeatRes::new)
        }
    }
}

impl ::protobuf::Clear for HeartbeatRes {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HeartbeatRes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HeartbeatRes {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NotifyClose {
    // message fields
    pub uid: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NotifyClose {
    fn default() -> &'a NotifyClose {
        <NotifyClose as ::protobuf::Message>::default_instance()
    }
}

impl NotifyClose {
    pub fn new() -> NotifyClose {
        ::std::default::Default::default()
    }

    // string uid = 1;


    pub fn get_uid(&self) -> &str {
        &self.uid
    }
    pub fn clear_uid(&mut self) {
        self.uid.clear();
    }

    // Param is passed by value, moved
    pub fn set_uid(&mut self, v: ::std::string::String) {
        self.uid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uid(&mut self) -> &mut ::std::string::String {
        &mut self.uid
    }

    // Take field
    pub fn take_uid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.uid, ::std::string::String::new())
    }
}

impl ::protobuf::Message for NotifyClose {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.uid)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.uid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.uid);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.uid.is_empty() {
            os.write_string(1, &self.uid)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NotifyClose {
        NotifyClose::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "uid",
                    |m: &NotifyClose| { &m.uid },
                    |m: &mut NotifyClose| { &mut m.uid },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NotifyClose>(
                    "NotifyClose",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NotifyClose {
        static mut instance: ::protobuf::lazy::Lazy<NotifyClose> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NotifyClose,
        };
        unsafe {
            instance.get(NotifyClose::new)
        }
    }
}

impl ::protobuf::Clear for NotifyClose {
    fn clear(&mut self) {
        self.uid.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NotifyClose {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NotifyClose {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TickUser {
    // message fields
    pub uid: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TickUser {
    fn default() -> &'a TickUser {
        <TickUser as ::protobuf::Message>::default_instance()
    }
}

impl TickUser {
    pub fn new() -> TickUser {
        ::std::default::Default::default()
    }

    // string uid = 1;


    pub fn get_uid(&self) -> &str {
        &self.uid
    }
    pub fn clear_uid(&mut self) {
        self.uid.clear();
    }

    // Param is passed by value, moved
    pub fn set_uid(&mut self, v: ::std::string::String) {
        self.uid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uid(&mut self) -> &mut ::std::string::String {
        &mut self.uid
    }

    // Take field
    pub fn take_uid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.uid, ::std::string::String::new())
    }
}

impl ::protobuf::Message for TickUser {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.uid)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.uid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.uid);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.uid.is_empty() {
            os.write_string(1, &self.uid)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TickUser {
        TickUser::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "uid",
                    |m: &TickUser| { &m.uid },
                    |m: &mut TickUser| { &mut m.uid },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TickUser>(
                    "TickUser",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TickUser {
        static mut instance: ::protobuf::lazy::Lazy<TickUser> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TickUser,
        };
        unsafe {
            instance.get(TickUser::new)
        }
    }
}

impl ::protobuf::Clear for TickUser {
    fn clear(&mut self) {
        self.uid.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TickUser {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TickUser {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct getOnlineUserNumReq {
    // message fields
    pub serverType: ::std::string::String,
    pub serverID: ::std::string::String,
    pub seqID: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a getOnlineUserNumReq {
    fn default() -> &'a getOnlineUserNumReq {
        <getOnlineUserNumReq as ::protobuf::Message>::default_instance()
    }
}

impl getOnlineUserNumReq {
    pub fn new() -> getOnlineUserNumReq {
        ::std::default::Default::default()
    }

    // string serverType = 1;


    pub fn get_serverType(&self) -> &str {
        &self.serverType
    }
    pub fn clear_serverType(&mut self) {
        self.serverType.clear();
    }

    // Param is passed by value, moved
    pub fn set_serverType(&mut self, v: ::std::string::String) {
        self.serverType = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_serverType(&mut self) -> &mut ::std::string::String {
        &mut self.serverType
    }

    // Take field
    pub fn take_serverType(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.serverType, ::std::string::String::new())
    }

    // string serverID = 2;


    pub fn get_serverID(&self) -> &str {
        &self.serverID
    }
    pub fn clear_serverID(&mut self) {
        self.serverID.clear();
    }

    // Param is passed by value, moved
    pub fn set_serverID(&mut self, v: ::std::string::String) {
        self.serverID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_serverID(&mut self) -> &mut ::std::string::String {
        &mut self.serverID
    }

    // Take field
    pub fn take_serverID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.serverID, ::std::string::String::new())
    }

    // string seqID = 3;


    pub fn get_seqID(&self) -> &str {
        &self.seqID
    }
    pub fn clear_seqID(&mut self) {
        self.seqID.clear();
    }

    // Param is passed by value, moved
    pub fn set_seqID(&mut self, v: ::std::string::String) {
        self.seqID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_seqID(&mut self) -> &mut ::std::string::String {
        &mut self.seqID
    }

    // Take field
    pub fn take_seqID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.seqID, ::std::string::String::new())
    }
}

impl ::protobuf::Message for getOnlineUserNumReq {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.serverType)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.serverID)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.seqID)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.serverType.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.serverType);
        }
        if !self.serverID.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.serverID);
        }
        if !self.seqID.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.seqID);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.serverType.is_empty() {
            os.write_string(1, &self.serverType)?;
        }
        if !self.serverID.is_empty() {
            os.write_string(2, &self.serverID)?;
        }
        if !self.seqID.is_empty() {
            os.write_string(3, &self.seqID)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> getOnlineUserNumReq {
        getOnlineUserNumReq::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "serverType",
                    |m: &getOnlineUserNumReq| { &m.serverType },
                    |m: &mut getOnlineUserNumReq| { &mut m.serverType },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "serverID",
                    |m: &getOnlineUserNumReq| { &m.serverID },
                    |m: &mut getOnlineUserNumReq| { &mut m.serverID },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "seqID",
                    |m: &getOnlineUserNumReq| { &m.seqID },
                    |m: &mut getOnlineUserNumReq| { &mut m.seqID },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<getOnlineUserNumReq>(
                    "getOnlineUserNumReq",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static getOnlineUserNumReq {
        static mut instance: ::protobuf::lazy::Lazy<getOnlineUserNumReq> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const getOnlineUserNumReq,
        };
        unsafe {
            instance.get(getOnlineUserNumReq::new)
        }
    }
}

impl ::protobuf::Clear for getOnlineUserNumReq {
    fn clear(&mut self) {
        self.serverType.clear();
        self.serverID.clear();
        self.seqID.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for getOnlineUserNumReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for getOnlineUserNumReq {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct onlineUserNum {
    // message fields
    pub serverType: ::std::string::String,
    pub serverID: ::std::string::String,
    pub channelID: ::std::string::String,
    pub num: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a onlineUserNum {
    fn default() -> &'a onlineUserNum {
        <onlineUserNum as ::protobuf::Message>::default_instance()
    }
}

impl onlineUserNum {
    pub fn new() -> onlineUserNum {
        ::std::default::Default::default()
    }

    // string serverType = 1;


    pub fn get_serverType(&self) -> &str {
        &self.serverType
    }
    pub fn clear_serverType(&mut self) {
        self.serverType.clear();
    }

    // Param is passed by value, moved
    pub fn set_serverType(&mut self, v: ::std::string::String) {
        self.serverType = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_serverType(&mut self) -> &mut ::std::string::String {
        &mut self.serverType
    }

    // Take field
    pub fn take_serverType(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.serverType, ::std::string::String::new())
    }

    // string serverID = 2;


    pub fn get_serverID(&self) -> &str {
        &self.serverID
    }
    pub fn clear_serverID(&mut self) {
        self.serverID.clear();
    }

    // Param is passed by value, moved
    pub fn set_serverID(&mut self, v: ::std::string::String) {
        self.serverID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_serverID(&mut self) -> &mut ::std::string::String {
        &mut self.serverID
    }

    // Take field
    pub fn take_serverID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.serverID, ::std::string::String::new())
    }

    // string channelID = 3;


    pub fn get_channelID(&self) -> &str {
        &self.channelID
    }
    pub fn clear_channelID(&mut self) {
        self.channelID.clear();
    }

    // Param is passed by value, moved
    pub fn set_channelID(&mut self, v: ::std::string::String) {
        self.channelID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_channelID(&mut self) -> &mut ::std::string::String {
        &mut self.channelID
    }

    // Take field
    pub fn take_channelID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.channelID, ::std::string::String::new())
    }

    // int32 num = 4;


    pub fn get_num(&self) -> i32 {
        self.num
    }
    pub fn clear_num(&mut self) {
        self.num = 0;
    }

    // Param is passed by value, moved
    pub fn set_num(&mut self, v: i32) {
        self.num = v;
    }
}

impl ::protobuf::Message for onlineUserNum {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.serverType)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.serverID)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.channelID)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.num = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.serverType.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.serverType);
        }
        if !self.serverID.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.serverID);
        }
        if !self.channelID.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.channelID);
        }
        if self.num != 0 {
            my_size += ::protobuf::rt::value_size(4, self.num, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.serverType.is_empty() {
            os.write_string(1, &self.serverType)?;
        }
        if !self.serverID.is_empty() {
            os.write_string(2, &self.serverID)?;
        }
        if !self.channelID.is_empty() {
            os.write_string(3, &self.channelID)?;
        }
        if self.num != 0 {
            os.write_int32(4, self.num)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> onlineUserNum {
        onlineUserNum::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "serverType",
                    |m: &onlineUserNum| { &m.serverType },
                    |m: &mut onlineUserNum| { &mut m.serverType },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "serverID",
                    |m: &onlineUserNum| { &m.serverID },
                    |m: &mut onlineUserNum| { &mut m.serverID },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "channelID",
                    |m: &onlineUserNum| { &m.channelID },
                    |m: &mut onlineUserNum| { &mut m.channelID },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "num",
                    |m: &onlineUserNum| { &m.num },
                    |m: &mut onlineUserNum| { &mut m.num },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<onlineUserNum>(
                    "onlineUserNum",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static onlineUserNum {
        static mut instance: ::protobuf::lazy::Lazy<onlineUserNum> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const onlineUserNum,
        };
        unsafe {
            instance.get(onlineUserNum::new)
        }
    }
}

impl ::protobuf::Clear for onlineUserNum {
    fn clear(&mut self) {
        self.serverType.clear();
        self.serverID.clear();
        self.channelID.clear();
        self.num = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for onlineUserNum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for onlineUserNum {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct getOnlineUserNumRes {
    // message fields
    pub onlineUserNum: ::protobuf::RepeatedField<onlineUserNum>,
    pub seqID: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a getOnlineUserNumRes {
    fn default() -> &'a getOnlineUserNumRes {
        <getOnlineUserNumRes as ::protobuf::Message>::default_instance()
    }
}

impl getOnlineUserNumRes {
    pub fn new() -> getOnlineUserNumRes {
        ::std::default::Default::default()
    }

    // repeated .GWC.onlineUserNum onlineUserNum = 1;


    pub fn get_onlineUserNum(&self) -> &[onlineUserNum] {
        &self.onlineUserNum
    }
    pub fn clear_onlineUserNum(&mut self) {
        self.onlineUserNum.clear();
    }

    // Param is passed by value, moved
    pub fn set_onlineUserNum(&mut self, v: ::protobuf::RepeatedField<onlineUserNum>) {
        self.onlineUserNum = v;
    }

    // Mutable pointer to the field.
    pub fn mut_onlineUserNum(&mut self) -> &mut ::protobuf::RepeatedField<onlineUserNum> {
        &mut self.onlineUserNum
    }

    // Take field
    pub fn take_onlineUserNum(&mut self) -> ::protobuf::RepeatedField<onlineUserNum> {
        ::std::mem::replace(&mut self.onlineUserNum, ::protobuf::RepeatedField::new())
    }

    // string seqID = 2;


    pub fn get_seqID(&self) -> &str {
        &self.seqID
    }
    pub fn clear_seqID(&mut self) {
        self.seqID.clear();
    }

    // Param is passed by value, moved
    pub fn set_seqID(&mut self, v: ::std::string::String) {
        self.seqID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_seqID(&mut self) -> &mut ::std::string::String {
        &mut self.seqID
    }

    // Take field
    pub fn take_seqID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.seqID, ::std::string::String::new())
    }
}

impl ::protobuf::Message for getOnlineUserNumRes {
    fn is_initialized(&self) -> bool {
        for v in &self.onlineUserNum {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.onlineUserNum)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.seqID)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.onlineUserNum {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.seqID.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.seqID);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.onlineUserNum {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.seqID.is_empty() {
            os.write_string(2, &self.seqID)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> getOnlineUserNumRes {
        getOnlineUserNumRes::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<onlineUserNum>>(
                    "onlineUserNum",
                    |m: &getOnlineUserNumRes| { &m.onlineUserNum },
                    |m: &mut getOnlineUserNumRes| { &mut m.onlineUserNum },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "seqID",
                    |m: &getOnlineUserNumRes| { &m.seqID },
                    |m: &mut getOnlineUserNumRes| { &mut m.seqID },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<getOnlineUserNumRes>(
                    "getOnlineUserNumRes",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static getOnlineUserNumRes {
        static mut instance: ::protobuf::lazy::Lazy<getOnlineUserNumRes> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const getOnlineUserNumRes,
        };
        unsafe {
            instance.get(getOnlineUserNumRes::new)
        }
    }
}

impl ::protobuf::Clear for getOnlineUserNumRes {
    fn clear(&mut self) {
        self.onlineUserNum.clear();
        self.seqID.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for getOnlineUserNumRes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for getOnlineUserNumRes {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct isOnlineReq {
    // message fields
    pub uids: ::std::string::String,
    pub seqID: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a isOnlineReq {
    fn default() -> &'a isOnlineReq {
        <isOnlineReq as ::protobuf::Message>::default_instance()
    }
}

impl isOnlineReq {
    pub fn new() -> isOnlineReq {
        ::std::default::Default::default()
    }

    // string uids = 1;


    pub fn get_uids(&self) -> &str {
        &self.uids
    }
    pub fn clear_uids(&mut self) {
        self.uids.clear();
    }

    // Param is passed by value, moved
    pub fn set_uids(&mut self, v: ::std::string::String) {
        self.uids = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uids(&mut self) -> &mut ::std::string::String {
        &mut self.uids
    }

    // Take field
    pub fn take_uids(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.uids, ::std::string::String::new())
    }

    // string seqID = 2;


    pub fn get_seqID(&self) -> &str {
        &self.seqID
    }
    pub fn clear_seqID(&mut self) {
        self.seqID.clear();
    }

    // Param is passed by value, moved
    pub fn set_seqID(&mut self, v: ::std::string::String) {
        self.seqID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_seqID(&mut self) -> &mut ::std::string::String {
        &mut self.seqID
    }

    // Take field
    pub fn take_seqID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.seqID, ::std::string::String::new())
    }
}

impl ::protobuf::Message for isOnlineReq {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.uids)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.seqID)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.uids.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.uids);
        }
        if !self.seqID.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.seqID);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.uids.is_empty() {
            os.write_string(1, &self.uids)?;
        }
        if !self.seqID.is_empty() {
            os.write_string(2, &self.seqID)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> isOnlineReq {
        isOnlineReq::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "uids",
                    |m: &isOnlineReq| { &m.uids },
                    |m: &mut isOnlineReq| { &mut m.uids },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "seqID",
                    |m: &isOnlineReq| { &m.seqID },
                    |m: &mut isOnlineReq| { &mut m.seqID },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<isOnlineReq>(
                    "isOnlineReq",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static isOnlineReq {
        static mut instance: ::protobuf::lazy::Lazy<isOnlineReq> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const isOnlineReq,
        };
        unsafe {
            instance.get(isOnlineReq::new)
        }
    }
}

impl ::protobuf::Clear for isOnlineReq {
    fn clear(&mut self) {
        self.uids.clear();
        self.seqID.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for isOnlineReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for isOnlineReq {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct userOnline {
    // message fields
    pub uid: ::std::string::String,
    pub online: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a userOnline {
    fn default() -> &'a userOnline {
        <userOnline as ::protobuf::Message>::default_instance()
    }
}

impl userOnline {
    pub fn new() -> userOnline {
        ::std::default::Default::default()
    }

    // string uid = 1;


    pub fn get_uid(&self) -> &str {
        &self.uid
    }
    pub fn clear_uid(&mut self) {
        self.uid.clear();
    }

    // Param is passed by value, moved
    pub fn set_uid(&mut self, v: ::std::string::String) {
        self.uid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uid(&mut self) -> &mut ::std::string::String {
        &mut self.uid
    }

    // Take field
    pub fn take_uid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.uid, ::std::string::String::new())
    }

    // int32 online = 2;


    pub fn get_online(&self) -> i32 {
        self.online
    }
    pub fn clear_online(&mut self) {
        self.online = 0;
    }

    // Param is passed by value, moved
    pub fn set_online(&mut self, v: i32) {
        self.online = v;
    }
}

impl ::protobuf::Message for userOnline {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.uid)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.online = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.uid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.uid);
        }
        if self.online != 0 {
            my_size += ::protobuf::rt::value_size(2, self.online, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.uid.is_empty() {
            os.write_string(1, &self.uid)?;
        }
        if self.online != 0 {
            os.write_int32(2, self.online)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> userOnline {
        userOnline::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "uid",
                    |m: &userOnline| { &m.uid },
                    |m: &mut userOnline| { &mut m.uid },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "online",
                    |m: &userOnline| { &m.online },
                    |m: &mut userOnline| { &mut m.online },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<userOnline>(
                    "userOnline",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static userOnline {
        static mut instance: ::protobuf::lazy::Lazy<userOnline> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const userOnline,
        };
        unsafe {
            instance.get(userOnline::new)
        }
    }
}

impl ::protobuf::Clear for userOnline {
    fn clear(&mut self) {
        self.uid.clear();
        self.online = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for userOnline {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for userOnline {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct isOnlineRes {
    // message fields
    pub userOnline: ::protobuf::RepeatedField<userOnline>,
    pub seqID: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a isOnlineRes {
    fn default() -> &'a isOnlineRes {
        <isOnlineRes as ::protobuf::Message>::default_instance()
    }
}

impl isOnlineRes {
    pub fn new() -> isOnlineRes {
        ::std::default::Default::default()
    }

    // repeated .GWC.userOnline userOnline = 1;


    pub fn get_userOnline(&self) -> &[userOnline] {
        &self.userOnline
    }
    pub fn clear_userOnline(&mut self) {
        self.userOnline.clear();
    }

    // Param is passed by value, moved
    pub fn set_userOnline(&mut self, v: ::protobuf::RepeatedField<userOnline>) {
        self.userOnline = v;
    }

    // Mutable pointer to the field.
    pub fn mut_userOnline(&mut self) -> &mut ::protobuf::RepeatedField<userOnline> {
        &mut self.userOnline
    }

    // Take field
    pub fn take_userOnline(&mut self) -> ::protobuf::RepeatedField<userOnline> {
        ::std::mem::replace(&mut self.userOnline, ::protobuf::RepeatedField::new())
    }

    // string seqID = 2;


    pub fn get_seqID(&self) -> &str {
        &self.seqID
    }
    pub fn clear_seqID(&mut self) {
        self.seqID.clear();
    }

    // Param is passed by value, moved
    pub fn set_seqID(&mut self, v: ::std::string::String) {
        self.seqID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_seqID(&mut self) -> &mut ::std::string::String {
        &mut self.seqID
    }

    // Take field
    pub fn take_seqID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.seqID, ::std::string::String::new())
    }
}

impl ::protobuf::Message for isOnlineRes {
    fn is_initialized(&self) -> bool {
        for v in &self.userOnline {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.userOnline)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.seqID)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.userOnline {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.seqID.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.seqID);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.userOnline {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.seqID.is_empty() {
            os.write_string(2, &self.seqID)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> isOnlineRes {
        isOnlineRes::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<userOnline>>(
                    "userOnline",
                    |m: &isOnlineRes| { &m.userOnline },
                    |m: &mut isOnlineRes| { &mut m.userOnline },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "seqID",
                    |m: &isOnlineRes| { &m.seqID },
                    |m: &mut isOnlineRes| { &mut m.seqID },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<isOnlineRes>(
                    "isOnlineRes",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static isOnlineRes {
        static mut instance: ::protobuf::lazy::Lazy<isOnlineRes> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const isOnlineRes,
        };
        unsafe {
            instance.get(isOnlineRes::new)
        }
    }
}

impl ::protobuf::Clear for isOnlineRes {
    fn clear(&mut self) {
        self.userOnline.clear();
        self.seqID.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for isOnlineRes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for isOnlineRes {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct forbiddenIp {
    // message fields
    pub field_type: i32,
    pub ip: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a forbiddenIp {
    fn default() -> &'a forbiddenIp {
        <forbiddenIp as ::protobuf::Message>::default_instance()
    }
}

impl forbiddenIp {
    pub fn new() -> forbiddenIp {
        ::std::default::Default::default()
    }

    // int32 type = 1;


    pub fn get_field_type(&self) -> i32 {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = 0;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: i32) {
        self.field_type = v;
    }

    // string ip = 2;


    pub fn get_ip(&self) -> &str {
        &self.ip
    }
    pub fn clear_ip(&mut self) {
        self.ip.clear();
    }

    // Param is passed by value, moved
    pub fn set_ip(&mut self, v: ::std::string::String) {
        self.ip = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ip(&mut self) -> &mut ::std::string::String {
        &mut self.ip
    }

    // Take field
    pub fn take_ip(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ip, ::std::string::String::new())
    }
}

impl ::protobuf::Message for forbiddenIp {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.field_type = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ip)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_type != 0 {
            my_size += ::protobuf::rt::value_size(1, self.field_type, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.ip.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.ip);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.field_type != 0 {
            os.write_int32(1, self.field_type)?;
        }
        if !self.ip.is_empty() {
            os.write_string(2, &self.ip)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> forbiddenIp {
        forbiddenIp::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "type",
                    |m: &forbiddenIp| { &m.field_type },
                    |m: &mut forbiddenIp| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ip",
                    |m: &forbiddenIp| { &m.ip },
                    |m: &mut forbiddenIp| { &mut m.ip },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<forbiddenIp>(
                    "forbiddenIp",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static forbiddenIp {
        static mut instance: ::protobuf::lazy::Lazy<forbiddenIp> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const forbiddenIp,
        };
        unsafe {
            instance.get(forbiddenIp::new)
        }
    }
}

impl ::protobuf::Clear for forbiddenIp {
    fn clear(&mut self) {
        self.field_type = 0;
        self.ip.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for forbiddenIp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for forbiddenIp {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BroadcastToGameServer {
    // message fields
    pub serverType: ::std::string::String,
    pub serverID: ::std::string::String,
    pub payload: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BroadcastToGameServer {
    fn default() -> &'a BroadcastToGameServer {
        <BroadcastToGameServer as ::protobuf::Message>::default_instance()
    }
}

impl BroadcastToGameServer {
    pub fn new() -> BroadcastToGameServer {
        ::std::default::Default::default()
    }

    // string serverType = 1;


    pub fn get_serverType(&self) -> &str {
        &self.serverType
    }
    pub fn clear_serverType(&mut self) {
        self.serverType.clear();
    }

    // Param is passed by value, moved
    pub fn set_serverType(&mut self, v: ::std::string::String) {
        self.serverType = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_serverType(&mut self) -> &mut ::std::string::String {
        &mut self.serverType
    }

    // Take field
    pub fn take_serverType(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.serverType, ::std::string::String::new())
    }

    // string serverID = 2;


    pub fn get_serverID(&self) -> &str {
        &self.serverID
    }
    pub fn clear_serverID(&mut self) {
        self.serverID.clear();
    }

    // Param is passed by value, moved
    pub fn set_serverID(&mut self, v: ::std::string::String) {
        self.serverID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_serverID(&mut self) -> &mut ::std::string::String {
        &mut self.serverID
    }

    // Take field
    pub fn take_serverID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.serverID, ::std::string::String::new())
    }

    // bytes payload = 3;


    pub fn get_payload(&self) -> &[u8] {
        &self.payload
    }
    pub fn clear_payload(&mut self) {
        self.payload.clear();
    }

    // Param is passed by value, moved
    pub fn set_payload(&mut self, v: ::std::vec::Vec<u8>) {
        self.payload = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payload(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.payload
    }

    // Take field
    pub fn take_payload(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.payload, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for BroadcastToGameServer {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.serverType)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.serverID)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.payload)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.serverType.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.serverType);
        }
        if !self.serverID.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.serverID);
        }
        if !self.payload.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.payload);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.serverType.is_empty() {
            os.write_string(1, &self.serverType)?;
        }
        if !self.serverID.is_empty() {
            os.write_string(2, &self.serverID)?;
        }
        if !self.payload.is_empty() {
            os.write_bytes(3, &self.payload)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BroadcastToGameServer {
        BroadcastToGameServer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "serverType",
                    |m: &BroadcastToGameServer| { &m.serverType },
                    |m: &mut BroadcastToGameServer| { &mut m.serverType },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "serverID",
                    |m: &BroadcastToGameServer| { &m.serverID },
                    |m: &mut BroadcastToGameServer| { &mut m.serverID },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "payload",
                    |m: &BroadcastToGameServer| { &m.payload },
                    |m: &mut BroadcastToGameServer| { &mut m.payload },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<BroadcastToGameServer>(
                    "BroadcastToGameServer",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static BroadcastToGameServer {
        static mut instance: ::protobuf::lazy::Lazy<BroadcastToGameServer> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const BroadcastToGameServer,
        };
        unsafe {
            instance.get(BroadcastToGameServer::new)
        }
    }
}

impl ::protobuf::Clear for BroadcastToGameServer {
    fn clear(&mut self) {
        self.serverType.clear();
        self.serverID.clear();
        self.payload.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BroadcastToGameServer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BroadcastToGameServer {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct isPlayingGameReq {
    // message fields
    pub uid: ::std::string::String,
    pub seqID: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a isPlayingGameReq {
    fn default() -> &'a isPlayingGameReq {
        <isPlayingGameReq as ::protobuf::Message>::default_instance()
    }
}

impl isPlayingGameReq {
    pub fn new() -> isPlayingGameReq {
        ::std::default::Default::default()
    }

    // string uid = 1;


    pub fn get_uid(&self) -> &str {
        &self.uid
    }
    pub fn clear_uid(&mut self) {
        self.uid.clear();
    }

    // Param is passed by value, moved
    pub fn set_uid(&mut self, v: ::std::string::String) {
        self.uid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uid(&mut self) -> &mut ::std::string::String {
        &mut self.uid
    }

    // Take field
    pub fn take_uid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.uid, ::std::string::String::new())
    }

    // string seqID = 2;


    pub fn get_seqID(&self) -> &str {
        &self.seqID
    }
    pub fn clear_seqID(&mut self) {
        self.seqID.clear();
    }

    // Param is passed by value, moved
    pub fn set_seqID(&mut self, v: ::std::string::String) {
        self.seqID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_seqID(&mut self) -> &mut ::std::string::String {
        &mut self.seqID
    }

    // Take field
    pub fn take_seqID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.seqID, ::std::string::String::new())
    }
}

impl ::protobuf::Message for isPlayingGameReq {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.uid)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.seqID)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.uid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.uid);
        }
        if !self.seqID.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.seqID);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.uid.is_empty() {
            os.write_string(1, &self.uid)?;
        }
        if !self.seqID.is_empty() {
            os.write_string(2, &self.seqID)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> isPlayingGameReq {
        isPlayingGameReq::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "uid",
                    |m: &isPlayingGameReq| { &m.uid },
                    |m: &mut isPlayingGameReq| { &mut m.uid },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "seqID",
                    |m: &isPlayingGameReq| { &m.seqID },
                    |m: &mut isPlayingGameReq| { &mut m.seqID },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<isPlayingGameReq>(
                    "isPlayingGameReq",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static isPlayingGameReq {
        static mut instance: ::protobuf::lazy::Lazy<isPlayingGameReq> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const isPlayingGameReq,
        };
        unsafe {
            instance.get(isPlayingGameReq::new)
        }
    }
}

impl ::protobuf::Clear for isPlayingGameReq {
    fn clear(&mut self) {
        self.uid.clear();
        self.seqID.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for isPlayingGameReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for isPlayingGameReq {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct isPlayingGameRes {
    // message fields
    pub isPlaying: i32,
    pub seqID: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a isPlayingGameRes {
    fn default() -> &'a isPlayingGameRes {
        <isPlayingGameRes as ::protobuf::Message>::default_instance()
    }
}

impl isPlayingGameRes {
    pub fn new() -> isPlayingGameRes {
        ::std::default::Default::default()
    }

    // int32 isPlaying = 1;


    pub fn get_isPlaying(&self) -> i32 {
        self.isPlaying
    }
    pub fn clear_isPlaying(&mut self) {
        self.isPlaying = 0;
    }

    // Param is passed by value, moved
    pub fn set_isPlaying(&mut self, v: i32) {
        self.isPlaying = v;
    }

    // string seqID = 2;


    pub fn get_seqID(&self) -> &str {
        &self.seqID
    }
    pub fn clear_seqID(&mut self) {
        self.seqID.clear();
    }

    // Param is passed by value, moved
    pub fn set_seqID(&mut self, v: ::std::string::String) {
        self.seqID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_seqID(&mut self) -> &mut ::std::string::String {
        &mut self.seqID
    }

    // Take field
    pub fn take_seqID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.seqID, ::std::string::String::new())
    }
}

impl ::protobuf::Message for isPlayingGameRes {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.isPlaying = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.seqID)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.isPlaying != 0 {
            my_size += ::protobuf::rt::value_size(1, self.isPlaying, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.seqID.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.seqID);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.isPlaying != 0 {
            os.write_int32(1, self.isPlaying)?;
        }
        if !self.seqID.is_empty() {
            os.write_string(2, &self.seqID)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> isPlayingGameRes {
        isPlayingGameRes::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "isPlaying",
                    |m: &isPlayingGameRes| { &m.isPlaying },
                    |m: &mut isPlayingGameRes| { &mut m.isPlaying },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "seqID",
                    |m: &isPlayingGameRes| { &m.seqID },
                    |m: &mut isPlayingGameRes| { &mut m.seqID },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<isPlayingGameRes>(
                    "isPlayingGameRes",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static isPlayingGameRes {
        static mut instance: ::protobuf::lazy::Lazy<isPlayingGameRes> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const isPlayingGameRes,
        };
        unsafe {
            instance.get(isPlayingGameRes::new)
        }
    }
}

impl ::protobuf::Clear for isPlayingGameRes {
    fn clear(&mut self) {
        self.isPlaying = 0;
        self.seqID.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for isPlayingGameRes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for isPlayingGameRes {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UserAddGold {
    // message fields
    pub uid: ::std::string::String,
    pub addGold: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UserAddGold {
    fn default() -> &'a UserAddGold {
        <UserAddGold as ::protobuf::Message>::default_instance()
    }
}

impl UserAddGold {
    pub fn new() -> UserAddGold {
        ::std::default::Default::default()
    }

    // string uid = 1;


    pub fn get_uid(&self) -> &str {
        &self.uid
    }
    pub fn clear_uid(&mut self) {
        self.uid.clear();
    }

    // Param is passed by value, moved
    pub fn set_uid(&mut self, v: ::std::string::String) {
        self.uid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uid(&mut self) -> &mut ::std::string::String {
        &mut self.uid
    }

    // Take field
    pub fn take_uid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.uid, ::std::string::String::new())
    }

    // uint64 addGold = 2;


    pub fn get_addGold(&self) -> u64 {
        self.addGold
    }
    pub fn clear_addGold(&mut self) {
        self.addGold = 0;
    }

    // Param is passed by value, moved
    pub fn set_addGold(&mut self, v: u64) {
        self.addGold = v;
    }
}

impl ::protobuf::Message for UserAddGold {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.uid)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.addGold = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.uid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.uid);
        }
        if self.addGold != 0 {
            my_size += ::protobuf::rt::value_size(2, self.addGold, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.uid.is_empty() {
            os.write_string(1, &self.uid)?;
        }
        if self.addGold != 0 {
            os.write_uint64(2, self.addGold)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UserAddGold {
        UserAddGold::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "uid",
                    |m: &UserAddGold| { &m.uid },
                    |m: &mut UserAddGold| { &mut m.uid },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "addGold",
                    |m: &UserAddGold| { &m.addGold },
                    |m: &mut UserAddGold| { &mut m.addGold },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UserAddGold>(
                    "UserAddGold",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UserAddGold {
        static mut instance: ::protobuf::lazy::Lazy<UserAddGold> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UserAddGold,
        };
        unsafe {
            instance.get(UserAddGold::new)
        }
    }
}

impl ::protobuf::Clear for UserAddGold {
    fn clear(&mut self) {
        self.uid.clear();
        self.addGold = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UserAddGold {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserAddGold {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReportServerInfo {
    // message fields
    pub serverType: ::std::string::String,
    pub serverID: ::std::string::String,
    pub serverURI: ::std::string::String,
    pub gwcURI: ::std::string::String,
    pub max: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReportServerInfo {
    fn default() -> &'a ReportServerInfo {
        <ReportServerInfo as ::protobuf::Message>::default_instance()
    }
}

impl ReportServerInfo {
    pub fn new() -> ReportServerInfo {
        ::std::default::Default::default()
    }

    // string serverType = 1;


    pub fn get_serverType(&self) -> &str {
        &self.serverType
    }
    pub fn clear_serverType(&mut self) {
        self.serverType.clear();
    }

    // Param is passed by value, moved
    pub fn set_serverType(&mut self, v: ::std::string::String) {
        self.serverType = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_serverType(&mut self) -> &mut ::std::string::String {
        &mut self.serverType
    }

    // Take field
    pub fn take_serverType(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.serverType, ::std::string::String::new())
    }

    // string serverID = 2;


    pub fn get_serverID(&self) -> &str {
        &self.serverID
    }
    pub fn clear_serverID(&mut self) {
        self.serverID.clear();
    }

    // Param is passed by value, moved
    pub fn set_serverID(&mut self, v: ::std::string::String) {
        self.serverID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_serverID(&mut self) -> &mut ::std::string::String {
        &mut self.serverID
    }

    // Take field
    pub fn take_serverID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.serverID, ::std::string::String::new())
    }

    // string serverURI = 3;


    pub fn get_serverURI(&self) -> &str {
        &self.serverURI
    }
    pub fn clear_serverURI(&mut self) {
        self.serverURI.clear();
    }

    // Param is passed by value, moved
    pub fn set_serverURI(&mut self, v: ::std::string::String) {
        self.serverURI = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_serverURI(&mut self) -> &mut ::std::string::String {
        &mut self.serverURI
    }

    // Take field
    pub fn take_serverURI(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.serverURI, ::std::string::String::new())
    }

    // string gwcURI = 4;


    pub fn get_gwcURI(&self) -> &str {
        &self.gwcURI
    }
    pub fn clear_gwcURI(&mut self) {
        self.gwcURI.clear();
    }

    // Param is passed by value, moved
    pub fn set_gwcURI(&mut self, v: ::std::string::String) {
        self.gwcURI = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gwcURI(&mut self) -> &mut ::std::string::String {
        &mut self.gwcURI
    }

    // Take field
    pub fn take_gwcURI(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.gwcURI, ::std::string::String::new())
    }

    // int32 max = 5;


    pub fn get_max(&self) -> i32 {
        self.max
    }
    pub fn clear_max(&mut self) {
        self.max = 0;
    }

    // Param is passed by value, moved
    pub fn set_max(&mut self, v: i32) {
        self.max = v;
    }
}

impl ::protobuf::Message for ReportServerInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.serverType)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.serverID)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.serverURI)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.gwcURI)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.max = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.serverType.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.serverType);
        }
        if !self.serverID.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.serverID);
        }
        if !self.serverURI.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.serverURI);
        }
        if !self.gwcURI.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.gwcURI);
        }
        if self.max != 0 {
            my_size += ::protobuf::rt::value_size(5, self.max, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.serverType.is_empty() {
            os.write_string(1, &self.serverType)?;
        }
        if !self.serverID.is_empty() {
            os.write_string(2, &self.serverID)?;
        }
        if !self.serverURI.is_empty() {
            os.write_string(3, &self.serverURI)?;
        }
        if !self.gwcURI.is_empty() {
            os.write_string(4, &self.gwcURI)?;
        }
        if self.max != 0 {
            os.write_int32(5, self.max)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReportServerInfo {
        ReportServerInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "serverType",
                    |m: &ReportServerInfo| { &m.serverType },
                    |m: &mut ReportServerInfo| { &mut m.serverType },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "serverID",
                    |m: &ReportServerInfo| { &m.serverID },
                    |m: &mut ReportServerInfo| { &mut m.serverID },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "serverURI",
                    |m: &ReportServerInfo| { &m.serverURI },
                    |m: &mut ReportServerInfo| { &mut m.serverURI },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "gwcURI",
                    |m: &ReportServerInfo| { &m.gwcURI },
                    |m: &mut ReportServerInfo| { &mut m.gwcURI },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "max",
                    |m: &ReportServerInfo| { &m.max },
                    |m: &mut ReportServerInfo| { &mut m.max },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ReportServerInfo>(
                    "ReportServerInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ReportServerInfo {
        static mut instance: ::protobuf::lazy::Lazy<ReportServerInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ReportServerInfo,
        };
        unsafe {
            instance.get(ReportServerInfo::new)
        }
    }
}

impl ::protobuf::Clear for ReportServerInfo {
    fn clear(&mut self) {
        self.serverType.clear();
        self.serverID.clear();
        self.serverURI.clear();
        self.gwcURI.clear();
        self.max = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReportServerInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReportServerInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MaintenanceReq {
    // message fields
    pub flg: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MaintenanceReq {
    fn default() -> &'a MaintenanceReq {
        <MaintenanceReq as ::protobuf::Message>::default_instance()
    }
}

impl MaintenanceReq {
    pub fn new() -> MaintenanceReq {
        ::std::default::Default::default()
    }

    // int32 flg = 1;


    pub fn get_flg(&self) -> i32 {
        self.flg
    }
    pub fn clear_flg(&mut self) {
        self.flg = 0;
    }

    // Param is passed by value, moved
    pub fn set_flg(&mut self, v: i32) {
        self.flg = v;
    }
}

impl ::protobuf::Message for MaintenanceReq {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.flg = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.flg != 0 {
            my_size += ::protobuf::rt::value_size(1, self.flg, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.flg != 0 {
            os.write_int32(1, self.flg)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MaintenanceReq {
        MaintenanceReq::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "flg",
                    |m: &MaintenanceReq| { &m.flg },
                    |m: &mut MaintenanceReq| { &mut m.flg },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MaintenanceReq>(
                    "MaintenanceReq",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MaintenanceReq {
        static mut instance: ::protobuf::lazy::Lazy<MaintenanceReq> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MaintenanceReq,
        };
        unsafe {
            instance.get(MaintenanceReq::new)
        }
    }
}

impl ::protobuf::Clear for MaintenanceReq {
    fn clear(&mut self) {
        self.flg = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MaintenanceReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MaintenanceReq {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NotifyAccountAndAameRecordSyncException {
    // message fields
    pub uid: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NotifyAccountAndAameRecordSyncException {
    fn default() -> &'a NotifyAccountAndAameRecordSyncException {
        <NotifyAccountAndAameRecordSyncException as ::protobuf::Message>::default_instance()
    }
}

impl NotifyAccountAndAameRecordSyncException {
    pub fn new() -> NotifyAccountAndAameRecordSyncException {
        ::std::default::Default::default()
    }

    // string uid = 1;


    pub fn get_uid(&self) -> &str {
        &self.uid
    }
    pub fn clear_uid(&mut self) {
        self.uid.clear();
    }

    // Param is passed by value, moved
    pub fn set_uid(&mut self, v: ::std::string::String) {
        self.uid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uid(&mut self) -> &mut ::std::string::String {
        &mut self.uid
    }

    // Take field
    pub fn take_uid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.uid, ::std::string::String::new())
    }
}

impl ::protobuf::Message for NotifyAccountAndAameRecordSyncException {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.uid)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.uid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.uid);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.uid.is_empty() {
            os.write_string(1, &self.uid)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NotifyAccountAndAameRecordSyncException {
        NotifyAccountAndAameRecordSyncException::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "uid",
                    |m: &NotifyAccountAndAameRecordSyncException| { &m.uid },
                    |m: &mut NotifyAccountAndAameRecordSyncException| { &mut m.uid },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NotifyAccountAndAameRecordSyncException>(
                    "NotifyAccountAndAameRecordSyncException",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NotifyAccountAndAameRecordSyncException {
        static mut instance: ::protobuf::lazy::Lazy<NotifyAccountAndAameRecordSyncException> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NotifyAccountAndAameRecordSyncException,
        };
        unsafe {
            instance.get(NotifyAccountAndAameRecordSyncException::new)
        }
    }
}

impl ::protobuf::Clear for NotifyAccountAndAameRecordSyncException {
    fn clear(&mut self) {
        self.uid.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NotifyAccountAndAameRecordSyncException {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NotifyAccountAndAameRecordSyncException {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\tgwc.proto\x12\x03GWC\"@\n\x0eBroadcastByUID\x12\x19\n\x04uids\x18\
    \x01\x20\x03(\x0b2\t.GWC.UidsB\0\x12\x11\n\x07payload\x18\x02\x20\x01(\
    \x0cB\0:\0\"\x17\n\x04Uids\x12\r\n\x03uid\x18\x01\x20\x01(\tB\0:\0\"J\n\
    \tBroadcast\x12\x14\n\nserverType\x18\x01\x20\x01(\tB\0\x12\x12\n\x08ser\
    verID\x18\x02\x20\x01(\tB\0\x12\x11\n\x07payload\x18\x03\x20\x01(\x0cB\0\
    :\0\"\x10\n\x0cHeartbeatReq:\0\"\x10\n\x0cHeartbeatRes:\0\"\x1e\n\x0bNot\
    ifyClose\x12\r\n\x03uid\x18\x01\x20\x01(\tB\0:\0\"\x1b\n\x08TickUser\x12\
    \r\n\x03uid\x18\x01\x20\x01(\tB\0:\0\"R\n\x13getOnlineUserNumReq\x12\x14\
    \n\nserverType\x18\x01\x20\x01(\tB\0\x12\x12\n\x08serverID\x18\x02\x20\
    \x01(\tB\0\x12\x0f\n\x05seqID\x18\x03\x20\x01(\tB\0:\0\"_\n\ronlineUserN\
    um\x12\x14\n\nserverType\x18\x01\x20\x01(\tB\0\x12\x12\n\x08serverID\x18\
    \x02\x20\x01(\tB\0\x12\x13\n\tchannelID\x18\x03\x20\x01(\tB\0\x12\r\n\
    \x03num\x18\x04\x20\x01(\x05B\0:\0\"U\n\x13getOnlineUserNumRes\x12+\n\ro\
    nlineUserNum\x18\x01\x20\x03(\x0b2\x12.GWC.onlineUserNumB\0\x12\x0f\n\
    \x05seqID\x18\x02\x20\x01(\tB\0:\0\"0\n\x0bisOnlineReq\x12\x0e\n\x04uids\
    \x18\x01\x20\x01(\tB\0\x12\x0f\n\x05seqID\x18\x02\x20\x01(\tB\0:\0\"/\n\
    \nuserOnline\x12\r\n\x03uid\x18\x01\x20\x01(\tB\0\x12\x10\n\x06online\
    \x18\x02\x20\x01(\x05B\0:\0\"G\n\x0bisOnlineRes\x12%\n\nuserOnline\x18\
    \x01\x20\x03(\x0b2\x0f.GWC.userOnlineB\0\x12\x0f\n\x05seqID\x18\x02\x20\
    \x01(\tB\0:\0\"-\n\x0bforbiddenIp\x12\x0e\n\x04type\x18\x01\x20\x01(\x05\
    B\0\x12\x0c\n\x02ip\x18\x02\x20\x01(\tB\0:\0\"V\n\x15BroadcastToGameServ\
    er\x12\x14\n\nserverType\x18\x01\x20\x01(\tB\0\x12\x12\n\x08serverID\x18\
    \x02\x20\x01(\tB\0\x12\x11\n\x07payload\x18\x03\x20\x01(\x0cB\0:\0\"4\n\
    \x10isPlayingGameReq\x12\r\n\x03uid\x18\x01\x20\x01(\tB\0\x12\x0f\n\x05s\
    eqID\x18\x02\x20\x01(\tB\0:\0\":\n\x10isPlayingGameRes\x12\x13\n\tisPlay\
    ing\x18\x01\x20\x01(\x05B\0\x12\x0f\n\x05seqID\x18\x02\x20\x01(\tB\0:\0\
    \"1\n\x0bUserAddGold\x12\r\n\x03uid\x18\x01\x20\x01(\tB\0\x12\x11\n\x07a\
    ddGold\x18\x02\x20\x01(\x04B\0:\0\"t\n\x10ReportServerInfo\x12\x14\n\nse\
    rverType\x18\x01\x20\x01(\tB\0\x12\x12\n\x08serverID\x18\x02\x20\x01(\tB\
    \0\x12\x13\n\tserverURI\x18\x03\x20\x01(\tB\0\x12\x10\n\x06gwcURI\x18\
    \x04\x20\x01(\tB\0\x12\r\n\x03max\x18\x05\x20\x01(\x05B\0:\0\"!\n\x0eMai\
    ntenanceReq\x12\r\n\x03flg\x18\x01\x20\x01(\x05B\0:\0\":\n'NotifyAccount\
    AndAameRecordSyncException\x12\r\n\x03uid\x18\x01\x20\x01(\tB\0:\0B\0b\
    \x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
